import * as ts from 'typescript';
import ts__default from 'typescript';

/**
 * Callback type used for {@link forEachComment}.
 *
 * @category Callbacks
 */
type ForEachCommentCallback = (fullText: string, comment: ts.CommentRange) => void;
/**
 * Iterates over all comments owned by `node` or its children.
 *
 * @category Nodes - Other Utilities
 */
declare function forEachComment(node: ts.Node, callback: ForEachCommentCallback, sourceFile?: ts.SourceFile): void;

/**
 * An option that can be tested with {@link isCompilerOptionEnabled}.
 *
 * @category Compiler Options
 */
type BooleanCompilerOptions = keyof {
    [K in keyof ts.CompilerOptions as NonNullable<ts.CompilerOptions[K]> extends boolean ? K : never]: unknown;
};
/**
 * Checks if a given compiler option is enabled.
 * It handles dependencies of options, e.g. `declaration` is implicitly enabled by `composite` or `strictNullChecks` is enabled by `strict`.
 * However, it does not check dependencies that are already checked and reported as errors, e.g. `checkJs` without `allowJs`.
 * This function only handles boolean flags.
 *
 * @category Compiler Options
 */
declare function isCompilerOptionEnabled(options: ts.CompilerOptions, option: BooleanCompilerOptions): boolean;
/**
 * An option that can be tested with {@link isStrictCompilerOptionEnabled}.
 *
 * @category Compiler Options
 */
type StrictCompilerOption = "alwaysStrict" | "noImplicitAny" | "noImplicitThis" | "strictBindCallApply" | "strictFunctionTypes" | "strictNullChecks" | "strictPropertyInitialization";
/**
 * Checks if a given compiler option is enabled, accounting for whether all flags
 * (except `strictPropertyInitialization`) have been enabled by `strict: true`.
 *
 * @category Compiler Options
 */
declare function isStrictCompilerOptionEnabled(options: ts.CompilerOptions, option: StrictCompilerOption): boolean;

/**
 * Test if the given node has the given `ModifierFlags` set.
 *
 * @category Nodes - Flag Utilities
 */
declare function isModifierFlagSet(node: ts.Declaration, flag: ts.ModifierFlags): boolean;
/**
 * Test if the given node has the given `NodeFlags` set.
 *
 * @category Nodes - Flag Utilities
 */
declare const isNodeFlagSet: (node: ts.Node, flag: ts.NodeFlags) => boolean;
/**
 * Test if the given node has the given `ObjectFlags` set.
 *
 * @category Nodes - Flag Utilities
 */
declare function isObjectFlagSet(objectType: ts.ObjectType, flag: ts.ObjectFlags): boolean;
/**
 * Test if the given node has the given `SymbolFlags` set.
 *
 * @category Nodes - Flag Utilities
 */
declare const isSymbolFlagSet: (symbol: ts.Symbol, flag: ts.SymbolFlags) => boolean;
/**
 * Test if the given node has the given `TypeFlags` set.
 *
 * @category Nodes - Flag Utilities
 */
declare const isTypeFlagSet: (type: ts.Type, flag: ts.TypeFlags) => boolean;

/**
 * Test if the given iterable contains a modifier of any of the given kinds.
 *
 * @category Modifier Utilities
 */
declare function hasModifier(modifiers: Iterable<ts.Modifier> | undefined, ...kinds: ts.ModifierSyntaxKind[]): boolean;

/**
 * An `AssertionExpression` that is declared as const.
 *
 * @category Node Types
 */
type ConstAssertionExpression = ts.AssertionExpression & {
    type: ts.TypeReferenceNode;
    typeName: ConstAssertionIdentifier;
};
/**
 * An `Identifier` with an `escapedText` value of `"const"`.
 *
 * @category Node Types
 */
type ConstAssertionIdentifier = ts.Identifier & {
    escapedText: ts.__String & "const";
};
/**
 * Test if a node is a {@link ConstAssertionExpression}.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a {@link ConstAssertionExpression}.
 */
declare function isConstAssertionExpression(node: ts.AssertionExpression): node is ConstAssertionExpression;
/**
 * Test if a node is an `IterationStatement`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be an `IterationStatement`.
 */
declare function isIterationStatement(node: ts.Node): node is ts.IterationStatement;
/**
 * Test if a node is a `JSDocNamespaceDeclaration`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `JSDocNamespaceDeclaration`.
 */
declare function isJSDocNamespaceDeclaration(node: ts.Node): node is ts.JSDocNamespaceDeclaration;
/**
 * Test if a node is a `JsxTagNamePropertyAccess`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `JsxTagNamePropertyAccess`.
 */
declare function isJsxTagNamePropertyAccess(node: ts.Node): node is ts.JsxTagNamePropertyAccess;
/**
 * a `NamedDeclaration` that definitely has a name.
 *
 * @category Node Types
 */
interface NamedDeclarationWithName extends ts.NamedDeclaration {
    name: ts.DeclarationName;
}
/**
 * Test if a node is a {@link NamedDeclarationWithName}.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a {@link NamedDeclarationWithName}.
 */
declare function isNamedDeclarationWithName(node: ts.Declaration): node is NamedDeclarationWithName;
/**
 * Test if a node is a `NamespaceDeclaration`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `NamespaceDeclaration`.
 */
declare function isNamespaceDeclaration(node: ts.Node): node is ts.NamespaceDeclaration;
/**
 * A number or sting literal (including string literals declare with \`\` quotes).
 *
 * @category Node Types
 */
type NumericOrStringLikeLiteral = ts.NumericLiteral | ts.StringLiteral | ts.NoSubstitutionTemplateLiteral;
/**
 * Test if a node is a {@link NumericOrStringLikeLiteral}.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a {@link NumericOrStringLikeLiteral}.
 */
declare function isNumericOrStringLikeLiteral(node: ts.Node): node is NumericOrStringLikeLiteral;
/**
 * Test if a node is a `PropertyAccessEntityNameExpression`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `PropertyAccessEntityNameExpression`.
 */
declare function isPropertyAccessEntityNameExpression(node: ts.Node): node is ts.PropertyAccessEntityNameExpression;
/**
 * Test if a node is a `SuperElementAccessExpression`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `SuperElementAccessExpression`.
 */
declare function isSuperElementAccessExpression(node: ts.Node): node is ts.SuperElementAccessExpression;
/**
 * Test if a node is a `SuperPropertyAccessExpression`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `SuperPropertyAccessExpression`.
 */
declare function isSuperPropertyAccessExpression(node: ts.Node): node is ts.SuperPropertyAccessExpression;

/**
 * A node that represents the any keyword.
 *
 * @category Node Types
 */
type AnyKeyword = ts.KeywordToken<ts.SyntaxKind.AnyKeyword>;
/**
 * A node that represents the bigint keyword.
 *
 * @category Node Types
 */
type BigIntKeyword = ts.KeywordToken<ts.SyntaxKind.BigIntKeyword>;
/**
 * A node that represents the boolean keyword.
 *
 * @category Node Types
 */
type BooleanKeyword = ts.KeywordToken<ts.SyntaxKind.BooleanKeyword>;
/**
 * A node that represents the false keyword.
 *
 * @category Node Types
 */
type FalseKeyword = ts.KeywordToken<ts.SyntaxKind.FalseKeyword>;
/**
 * A node that represents the import keyword.
 *
 * @category Node Types
 */
type ImportKeyword = ts.KeywordToken<ts.SyntaxKind.ImportKeyword>;
/**
 * A node that represents the never keyword.
 *
 * @category Node Types
 */
type NeverKeyword = ts.KeywordToken<ts.SyntaxKind.NeverKeyword>;
/**
 * A node that represents the null keyword.
 *
 * @category Node Types
 */
type NullKeyword = ts.KeywordToken<ts.SyntaxKind.NullKeyword>;
/**
 * A node that represents the number keyword.
 *
 * @category Node Types
 */
type NumberKeyword = ts.KeywordToken<ts.SyntaxKind.NumberKeyword>;
/**
 * A node that represents the object keyword.
 *
 * @category Node Types
 */
type ObjectKeyword = ts.KeywordToken<ts.SyntaxKind.ObjectKeyword>;
/**
 * A node that represents the string keyword.
 *
 * @category Node Types
 */
type StringKeyword = ts.KeywordToken<ts.SyntaxKind.StringKeyword>;
/**
 * A node that represents the super keyword.
 *
 * @category Node Types
 */
type SuperKeyword = ts.KeywordToken<ts.SyntaxKind.SuperKeyword>;
/**
 * A node that represents the symbol keyword.
 *
 * @category Node Types
 */
type SymbolKeyword = ts.KeywordToken<ts.SyntaxKind.SymbolKeyword>;
/**
 * A node that represents the this keyword.
 *
 * @category Node Types
 */
type ThisKeyword = ts.KeywordToken<ts.SyntaxKind.ThisKeyword>;
/**
 * A node that represents the true keyword.
 *
 * @category Node Types
 */
type TrueKeyword = ts.KeywordToken<ts.SyntaxKind.TrueKeyword>;
/**
 * A node that represents the undefined keyword.
 *
 * @category Node Types
 */
type UndefinedKeyword = ts.KeywordToken<ts.SyntaxKind.UndefinedKeyword>;
/**
 * A node that represents the unknown keyword.
 *
 * @category Node Types
 */
type UnknownKeyword = ts.KeywordToken<ts.SyntaxKind.UnknownKeyword>;
/**
 * A node that represents the void keyword.
 *
 * @category Node Types
 */
type VoidKeyword = ts.KeywordToken<ts.SyntaxKind.VoidKeyword>;
/**
 * Test if a node is an `AbstractKeyword`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be an `AbstractKeyword`.
 */
declare function isAbstractKeyword(node: ts.Node): node is ts.AbstractKeyword;
/**
 * Test if a node is an `AccessorKeyword`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be an `AccessorKeyword`.
 */
declare function isAccessorKeyword(node: ts.Node): node is ts.AccessorKeyword;
/**
 * Test if a node is an {@link AnyKeyword}.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be an {@link AnyKeyword}.
 */
declare function isAnyKeyword(node: ts.Node): node is AnyKeyword;
/**
 * Test if a node is an `AssertKeyword`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be an `AssertKeyword`.
 */
declare function isAssertKeyword(node: ts.Node): node is ts.AssertKeyword;
/**
 * Test if a node is an `AssertsKeyword`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be an `AssertsKeyword`.
 */
declare function isAssertsKeyword(node: ts.Node): node is ts.AssertsKeyword;
/**
 * Test if a node is an `AsyncKeyword`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be an `AsyncKeyword`.
 */
declare function isAsyncKeyword(node: ts.Node): node is ts.AsyncKeyword;
/**
 * Test if a node is an `AwaitKeyword`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be an `AwaitKeyword`.
 */
declare function isAwaitKeyword(node: ts.Node): node is ts.AwaitKeyword;
/**
 * Test if a node is a {@link BigIntKeyword}.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a {@link BigIntKeyword}.
 */
declare function isBigIntKeyword(node: ts.Node): node is BigIntKeyword;
/**
 * Test if a node is a {@link BooleanKeyword}.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a {@link BooleanKeyword}.
 */
declare function isBooleanKeyword(node: ts.Node): node is BooleanKeyword;
/**
 * Test if a node is a `ColonToken`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `ColonToken`.
 */
declare function isColonToken(node: ts.Node): node is ts.ColonToken;
/**
 * Test if a node is a `ConstKeyword`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `ConstKeyword`.
 */
declare function isConstKeyword(node: ts.Node): node is ts.ConstKeyword;
/**
 * Test if a node is a `DeclareKeyword`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `DeclareKeyword`.
 */
declare function isDeclareKeyword(node: ts.Node): node is ts.DeclareKeyword;
/**
 * Test if a node is a `DefaultKeyword`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `DefaultKeyword`.
 */
declare function isDefaultKeyword(node: ts.Node): node is ts.DefaultKeyword;
/**
 * Test if a node is a `DotToken`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `DotToken`.
 */
declare function isDotToken(node: ts.Node): node is ts.DotToken;
/**
 * Test if a node is an `EndOfFileToken`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be an `EndOfFileToken`.
 */
declare function isEndOfFileToken(node: ts.Node): node is ts.EndOfFileToken;
/**
 * Test if a node is an `EqualsGreaterThanToken`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be an `EqualsGreaterThanToken`.
 */
declare function isEqualsGreaterThanToken(node: ts.Node): node is ts.EqualsGreaterThanToken;
/**
 * Test if a node is an `EqualsToken`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be an `EqualsToken`.
 */
declare function isEqualsToken(node: ts.Node): node is ts.EqualsToken;
/**
 * Test if a node is an `ExclamationToken`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be an `ExclamationToken`.
 */
declare function isExclamationToken(node: ts.Node): node is ts.ExclamationToken;
/**
 * Test if a node is an `ExportKeyword`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be an `ExportKeyword`.
 */
declare function isExportKeyword(node: ts.Node): node is ts.ExportKeyword;
/**
 * Test if a node is a {@link FalseKeyword}.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a {@link FalseKeyword}.
 */
declare function isFalseKeyword(node: ts.Node): node is FalseKeyword;
/**
 * Test if a node is a `FalseLiteral`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `FalseLiteral`.
 */
declare function isFalseLiteral(node: ts.Node): node is ts.FalseLiteral;
/**
 * Test if a node is an `ImportExpression`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be an `ImportExpression`.
 */
declare function isImportExpression(node: ts.Node): node is ts.ImportExpression;
/**
 * Test if a node is an {@link ImportKeyword}.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be an {@link ImportKeyword}.
 */
declare function isImportKeyword(node: ts.Node): node is ImportKeyword;
/**
 * Test if a node is an `InKeyword`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be an `InKeyword`.
 */
declare function isInKeyword(node: ts.Node): node is ts.InKeyword;
/**
 * Test if a node is an `InputFiles`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be an `InputFiles`.
 */
declare function isInputFiles(node: ts.Node): node is ts.InputFiles;
/**
 * Test if a node is a `JSDocText`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `JSDocText`.
 */
declare function isJSDocText(node: ts.Node): node is ts.JSDocText;
/**
 * Test if a node is a `JsonMinusNumericLiteral`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `JsonMinusNumericLiteral`.
 */
declare function isJsonMinusNumericLiteral(node: ts.Node): node is ts.JsonMinusNumericLiteral;
/**
 * Test if a node is a {@link NeverKeyword}.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a {@link NeverKeyword}.
 */
declare function isNeverKeyword(node: ts.Node): node is NeverKeyword;
/**
 * Test if a node is a {@link NullKeyword}.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a {@link NullKeyword}.
 */
declare function isNullKeyword(node: ts.Node): node is NullKeyword;
/**
 * Test if a node is a `NullLiteral`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `NullLiteral`.
 */
declare function isNullLiteral(node: ts.Node): node is ts.NullLiteral;
/**
 * Test if a node is a {@link NumberKeyword}.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a {@link NumberKeyword}.
 */
declare function isNumberKeyword(node: ts.Node): node is NumberKeyword;
/**
 * Test if a node is an {@link ObjectKeyword}.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be an {@link ObjectKeyword}.
 */
declare function isObjectKeyword(node: ts.Node): node is ObjectKeyword;
/**
 * Test if a node is an `OutKeyword`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be an `OutKeyword`.
 */
declare function isOutKeyword(node: ts.Node): node is ts.OutKeyword;
/**
 * Test if a node is an `OverrideKeyword`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be an `OverrideKeyword`.
 */
declare function isOverrideKeyword(node: ts.Node): node is ts.OverrideKeyword;
/**
 * Test if a node is a `PrivateKeyword`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `PrivateKeyword`.
 */
declare function isPrivateKeyword(node: ts.Node): node is ts.PrivateKeyword;
/**
 * Test if a node is a `ProtectedKeyword`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `ProtectedKeyword`.
 */
declare function isProtectedKeyword(node: ts.Node): node is ts.ProtectedKeyword;
/**
 * Test if a node is a `PublicKeyword`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `PublicKeyword`.
 */
declare function isPublicKeyword(node: ts.Node): node is ts.PublicKeyword;
/**
 * Test if a node is a `QuestionDotToken`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `QuestionDotToken`.
 */
declare function isQuestionDotToken(node: ts.Node): node is ts.QuestionDotToken;
/**
 * Test if a node is a `QuestionToken`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `QuestionToken`.
 */
declare function isQuestionToken(node: ts.Node): node is ts.QuestionToken;
/**
 * Test if a node is a `ReadonlyKeyword`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `ReadonlyKeyword`.
 */
declare function isReadonlyKeyword(node: ts.Node): node is ts.ReadonlyKeyword;
/**
 * Test if a node is a `StaticKeyword`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `StaticKeyword`.
 */
declare function isStaticKeyword(node: ts.Node): node is ts.StaticKeyword;
/**
 * Test if a node is a {@link StringKeyword}.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a {@link StringKeyword}.
 */
declare function isStringKeyword(node: ts.Node): node is StringKeyword;
/**
 * Test if a node is a `SuperExpression`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `SuperExpression`.
 */
declare function isSuperExpression(node: ts.Node): node is ts.SuperExpression;
/**
 * Test if a node is a {@link SuperKeyword}.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a {@link SuperKeyword}.
 */
declare function isSuperKeyword(node: ts.Node): node is SuperKeyword;
/**
 * Test if a node is a {@link SymbolKeyword}.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a {@link SymbolKeyword}.
 */
declare function isSymbolKeyword(node: ts.Node): node is SymbolKeyword;
/**
 * Test if a node is a `SyntaxList`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `SyntaxList`.
 */
declare function isSyntaxList(node: ts.Node): node is ts.SyntaxList;
/**
 * Test if a node is a `ThisExpression`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `ThisExpression`.
 */
declare function isThisExpression(node: ts.Node): node is ts.ThisExpression;
/**
 * Test if a node is a {@link ThisKeyword}.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a {@link ThisKeyword}.
 */
declare function isThisKeyword(node: ts.Node): node is ThisKeyword;
/**
 * Test if a node is a {@link TrueKeyword}.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a {@link TrueKeyword}.
 */
declare function isTrueKeyword(node: ts.Node): node is TrueKeyword;
/**
 * Test if a node is a `TrueLiteral`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `TrueLiteral`.
 */
declare function isTrueLiteral(node: ts.Node): node is ts.TrueLiteral;
/**
 * Test if a node is an {@link UndefinedKeyword}.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be an {@link UndefinedKeyword}.
 */
declare function isUndefinedKeyword(node: ts.Node): node is UndefinedKeyword;
/**
 * Test if a node is an {@link UnknownKeyword}.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be an {@link UnknownKeyword}.
 */
declare function isUnknownKeyword(node: ts.Node): node is UnknownKeyword;
/**
 * Test if a node is an `UnparsedPrologue`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be an `UnparsedPrologue`.
 */
declare function isUnparsedPrologue(node: ts.Node): node is ts.UnparsedPrologue;
/**
 * Test if a node is an `UnparsedSyntheticReference`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be an `UnparsedSyntheticReference`.
 */
declare function isUnparsedSyntheticReference(node: ts.Node): node is ts.UnparsedSyntheticReference;
/**
 * Test if a node is a {@link VoidKeyword}.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a {@link VoidKeyword}.
 */
declare function isVoidKeyword(node: ts.Node): node is VoidKeyword;

/**
 * Test if a node is an `AccessExpression`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be an `AccessExpression`.
 */
declare function isAccessExpression(node: ts.Node): node is ts.AccessExpression;
/**
 * Test if a node is an `AccessibilityModifier`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be an `AccessibilityModifier`.
 */
declare function isAccessibilityModifier(node: ts.Node): node is ts.AccessibilityModifier;
/**
 * Test if a node is an `AccessorDeclaration`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be an `AccessorDeclaration`.
 */
declare function isAccessorDeclaration(node: ts.Node): node is ts.AccessorDeclaration;
/**
 * Test if a node is an `ArrayBindingElement`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be an `ArrayBindingElement`.
 */
declare function isArrayBindingElement(node: ts.Node): node is ts.ArrayBindingElement;
/**
 * Test if a node is an `ArrayBindingOrAssignmentPattern`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be an `ArrayBindingOrAssignmentPattern`.
 */
declare function isArrayBindingOrAssignmentPattern(node: ts.Node): node is ts.ArrayBindingOrAssignmentPattern;
/**
 * Test if a node is an `AssignmentPattern`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be an `AssignmentPattern`.
 */
declare function isAssignmentPattern(node: ts.Node): node is ts.AssignmentPattern;
/**
 * Test if a node is a `BindingOrAssignmentElementRestIndicator`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `BindingOrAssignmentElementRestIndicator`.
 */
declare function isBindingOrAssignmentElementRestIndicator(node: ts.Node): node is ts.BindingOrAssignmentElementRestIndicator;
/**
 * Test if a node is a `BindingOrAssignmentElementTarget`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `BindingOrAssignmentElementTarget`.
 */
declare function isBindingOrAssignmentElementTarget(node: ts.Node): node is ts.BindingOrAssignmentElementTarget;
/**
 * Test if a node is a `BindingOrAssignmentPattern`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `BindingOrAssignmentPattern`.
 */
declare function isBindingOrAssignmentPattern(node: ts.Node): node is ts.BindingOrAssignmentPattern;
/**
 * Test if a node is a `BindingPattern`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `BindingPattern`.
 */
declare function isBindingPattern(node: ts.Node): node is ts.BindingPattern;
/**
 * Test if a node is a `BlockLike`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `BlockLike`.
 */
declare function isBlockLike(node: ts.Node): node is ts.BlockLike;
/**
 * Test if a node is a `BooleanLiteral`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `BooleanLiteral`.
 */
declare function isBooleanLiteral(node: ts.Node): node is ts.BooleanLiteral;
/**
 * Test if a node is a `ClassLikeDeclaration`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `ClassLikeDeclaration`.
 */
declare function isClassLikeDeclaration(node: ts.Node): node is ts.ClassLikeDeclaration;
/**
 * Test if a node is a `ClassMemberModifier`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `ClassMemberModifier`.
 */
declare function isClassMemberModifier(node: ts.Node): node is ts.ClassMemberModifier;
/**
 * Test if a node is a `DeclarationName`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `DeclarationName`.
 */
declare function isDeclarationName(node: ts.Node): node is ts.DeclarationName;
/**
 * Test if a node is a `DeclarationWithTypeParameterChildren`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `DeclarationWithTypeParameterChildren`.
 */
declare function isDeclarationWithTypeParameterChildren(node: ts.Node): node is ts.DeclarationWithTypeParameterChildren;
/**
 * Test if a node is a `DeclarationWithTypeParameters`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `DeclarationWithTypeParameters`.
 */
declare function isDeclarationWithTypeParameters(node: ts.Node): node is ts.DeclarationWithTypeParameters;
/**
 * Test if a node is a `DestructuringPattern`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `DestructuringPattern`.
 */
declare function isDestructuringPattern(node: ts.Node): node is ts.DestructuringPattern;
/**
 * Test if a node is an `EntityNameExpression`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be an `EntityNameExpression`.
 */
declare function isEntityNameExpression(node: ts.Node): node is ts.EntityNameExpression;
/**
 * Test if a node is an `EntityNameOrEntityNameExpression`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be an `EntityNameOrEntityNameExpression`.
 */
declare function isEntityNameOrEntityNameExpression(node: ts.Node): node is ts.EntityNameOrEntityNameExpression;
/**
 * Test if a node is a `ForInOrOfStatement`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `ForInOrOfStatement`.
 */
declare function isForInOrOfStatement(node: ts.Node): node is ts.ForInOrOfStatement;
/**
 * Test if a node is a `FunctionLikeDeclaration`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `FunctionLikeDeclaration`.
 */
declare function isFunctionLikeDeclaration(node: ts.Node): node is ts.FunctionLikeDeclaration;
/**
 * Test if a node is a `HasDecorators`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `HasDecorators`.
 */
declare function isHasDecorators(node: ts.Node): node is ts.HasDecorators;
/**
 * Test if a node is a `HasExpressionInitializer`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `HasExpressionInitializer`.
 */
declare function isHasExpressionInitializer(node: ts.Node): node is ts.HasExpressionInitializer;
/**
 * Test if a node is a `HasInitializer`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `HasInitializer`.
 */
declare function isHasInitializer(node: ts.Node): node is ts.HasInitializer;
/**
 * Test if a node is a `HasJSDoc`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `HasJSDoc`.
 */
declare function isHasJSDoc(node: ts.Node): node is ts.HasJSDoc;
/**
 * Test if a node is a `HasModifiers`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `HasModifiers`.
 */
declare function isHasModifiers(node: ts.Node): node is ts.HasModifiers;
/**
 * Test if a node is a `HasType`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `HasType`.
 */
declare function isHasType(node: ts.Node): node is ts.HasType;
/**
 * Test if a node is a `HasTypeArguments`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `HasTypeArguments`.
 */
declare function isHasTypeArguments(node: ts.Node): node is ts.HasTypeArguments;
/**
 * Test if a node is a `JSDocComment`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `JSDocComment`.
 */
declare function isJSDocComment(node: ts.Node): node is ts.JSDocComment;
/**
 * Test if a node is a `JSDocNamespaceBody`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `JSDocNamespaceBody`.
 */
declare function isJSDocNamespaceBody(node: ts.Node): node is ts.JSDocNamespaceBody;
/**
 * Test if a node is a `JSDocTypeReferencingNode`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `JSDocTypeReferencingNode`.
 */
declare function isJSDocTypeReferencingNode(node: ts.Node): node is ts.JSDocTypeReferencingNode;
/**
 * Test if a node is a `JsonObjectExpression`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `JsonObjectExpression`.
 */
declare function isJsonObjectExpression(node: ts.Node): node is ts.JsonObjectExpression;
/**
 * Test if a node is a `JsxAttributeLike`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `JsxAttributeLike`.
 */
declare function isJsxAttributeLike(node: ts.Node): node is ts.JsxAttributeLike;
/**
 * Test if a node is a `JsxAttributeValue`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `JsxAttributeValue`.
 */
declare function isJsxAttributeValue(node: ts.Node): node is ts.JsxAttributeValue;
/**
 * Test if a node is a `JsxChild`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `JsxChild`.
 */
declare function isJsxChild(node: ts.Node): node is ts.JsxChild;
/**
 * Test if a node is a `JsxTagNameExpression`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `JsxTagNameExpression`.
 */
declare function isJsxTagNameExpression(node: ts.Node): node is ts.JsxTagNameExpression;
/**
 * Test if a node is a `LiteralToken`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `LiteralToken`.
 */
declare function isLiteralToken(node: ts.Node): node is ts.LiteralToken;
/**
 * Test if a node is a `ModuleBody`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `ModuleBody`.
 */
declare function isModuleBody(node: ts.Node): node is ts.ModuleBody;
/**
 * Test if a node is a `ModuleName`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `ModuleName`.
 */
declare function isModuleName(node: ts.Node): node is ts.ModuleName;
/**
 * Test if a node is a `ModuleReference`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `ModuleReference`.
 */
declare function isModuleReference(node: ts.Node): node is ts.ModuleReference;
/**
 * Test if a node is a `NamedImportBindings`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `NamedImportBindings`.
 */
declare function isNamedImportBindings(node: ts.Node): node is ts.NamedImportBindings;
/**
 * Test if a node is a `NamedImportsOrExports`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `NamedImportsOrExports`.
 */
declare function isNamedImportsOrExports(node: ts.Node): node is ts.NamedImportsOrExports;
/**
 * Test if a node is a `NamespaceBody`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `NamespaceBody`.
 */
declare function isNamespaceBody(node: ts.Node): node is ts.NamespaceBody;
/**
 * Test if a node is an `ObjectBindingOrAssignmentElement`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be an `ObjectBindingOrAssignmentElement`.
 */
declare function isObjectBindingOrAssignmentElement(node: ts.Node): node is ts.ObjectBindingOrAssignmentElement;
/**
 * Test if a node is an `ObjectBindingOrAssignmentPattern`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be an `ObjectBindingOrAssignmentPattern`.
 */
declare function isObjectBindingOrAssignmentPattern(node: ts.Node): node is ts.ObjectBindingOrAssignmentPattern;
/**
 * Test if a node is an `ObjectTypeDeclaration`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be an `ObjectTypeDeclaration`.
 */
declare function isObjectTypeDeclaration(node: ts.Node): node is ts.ObjectTypeDeclaration;
/**
 * Test if a node is a `ParameterPropertyModifier`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `ParameterPropertyModifier`.
 */
declare function isParameterPropertyModifier(node: ts.Node): node is ts.ParameterPropertyModifier;
/**
 * Test if a node is a `PropertyNameLiteral`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `PropertyNameLiteral`.
 */
declare function isPropertyNameLiteral(node: ts.Node): node is ts.PropertyNameLiteral;
/**
 * Test if a node is a `PseudoLiteralToken`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `PseudoLiteralToken`.
 */
declare function isPseudoLiteralToken(node: ts.Node): node is ts.PseudoLiteralToken;
/**
 * Test if a node is a `SignatureDeclaration`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `SignatureDeclaration`.
 */
declare function isSignatureDeclaration(node: ts.Node): node is ts.SignatureDeclaration;
/**
 * Test if a node is a `SuperProperty`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `SuperProperty`.
 */
declare function isSuperProperty(node: ts.Node): node is ts.SuperProperty;
/**
 * Test if a node is a `TypeOnlyCompatibleAliasDeclaration`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `TypeOnlyCompatibleAliasDeclaration`.
 */
declare function isTypeOnlyCompatibleAliasDeclaration(node: ts.Node): node is ts.TypeOnlyCompatibleAliasDeclaration;
/**
 * Test if a node is a `TypeReferenceType`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `TypeReferenceType`.
 */
declare function isTypeReferenceType(node: ts.Node): node is ts.TypeReferenceType;
/**
 * Test if a node is an `UnionOrIntersectionTypeNode`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be an `UnionOrIntersectionTypeNode`.
 */
declare function isUnionOrIntersectionTypeNode(node: ts.Node): node is ts.UnionOrIntersectionTypeNode;
/**
 * Test if a node is an `UnparsedSourceText`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be an `UnparsedSourceText`.
 */
declare function isUnparsedSourceText(node: ts.Node): node is ts.UnparsedSourceText;
/**
 * Test if a node is a `VariableLikeDeclaration`.
 *
 * @category Nodes - Type Guards
 * @returns Whether the given node appears to be a `VariableLikeDeclaration`.
 */
declare function isVariableLikeDeclaration(node: ts.Node): node is ts.VariableLikeDeclaration;

/**
 * Is the node a scope boundary, specifically due to it being a function.
 *
 * @category Scope Utilities
 */
declare function isFunctionScopeBoundary(node: ts.Node): boolean;

/**
 * Test of the kind given is for assignment.
 *
 * @category Syntax Utilities
 */
declare function isAssignmentKind(kind: ts.SyntaxKind): boolean;
/**
 * Test if a string is numeric.
 *
 * @category Syntax Utilities
 */
declare function isNumericPropertyName(name: string | ts.__String): boolean;
/**
 * Determines whether the given text can be used to access a property with a `PropertyAccessExpression` while preserving the property's name.
 *
 * @category Syntax Utilities
 */
declare function isValidPropertyAccess(text: string, languageVersion?: ts.ScriptTarget): boolean;

/**
 * Callback type used for {@link forEachToken}.
 *
 * @category Callbacks
 */
type ForEachTokenCallback = (token: ts.Node) => void;
/**
 * Iterates over all tokens of `node`
 *
 * @category Nodes - Other Utilities
 * @param node - The node whose tokens should be visited
 * @param callback - Is called for every token contained in `node`
 */
declare function forEachToken(node: ts.Node, callback: ForEachTokenCallback, sourceFile?: ts.SourceFile): void;

/**
 * Get the `CallSignatures` of the given type.
 *
 * @category Types - Getters
 */
declare function getCallSignaturesOfType(type: ts.Type): readonly ts.Signature[];
/**
 * Get the property with the given name on the given type (if it exists).
 *
 * @category Types - Getters
 */
declare function getPropertyOfType(type: ts.Type, name: ts.__String): ts.Symbol | undefined;
/**
 * Retrieves a type symbol corresponding to a well-known string name.
 *
 * @category Types - Getters
 */
declare function getWellKnownSymbolPropertyOfType(type: ts.Type, wellKnownSymbolName: string, typeChecker: ts.TypeChecker): ts.Symbol | undefined;

/**
 * `LiteralType` from typescript except that it allows for it to work on arbitrary types.
 *
 * @category Type Types
 */
interface UnknownLiteralType extends ts.Type {
    freshType: UnknownLiteralType;
    regularType: UnknownLiteralType;
    value: unknown;
}
/**
 * A boolean literal.
 *
 * @category Type Types
 */
interface BooleanLiteralType extends UnknownLiteralType {
    value: boolean;
}
/**
 * A "true" literal.
 *
 * @category Type Types
 */
interface TrueLiteralType extends BooleanLiteralType {
    value: true;
}
/**
 * A "false" literal.
 *
 * @category Type Types
 */
interface FalseLiteralType extends BooleanLiteralType {
    value: false;
}
/**
 * Test if a type is a {@link UnknownLiteralType}?
 *
 * @param type
 * @returns
 */
declare function isUnknownLiteralType(type: ts.Type): type is UnknownLiteralType;
/**
 * Determines whether the given type is a boolean literal type.
 *
 * @category Types - Utilities
 */
declare function isBooleanLiteralType(type: ts.Type): type is BooleanLiteralType;
/**
 * Determines whether the given type is a boolean literal type for "true".
 *
 * @category Types - Utilities
 */
declare function isTrueLiteralType(type: ts.Type): type is TrueLiteralType;
/**
 * Determines whether the given type is a boolean literal type for "false".
 *
 * @category Types - Utilities
 */
declare function isFalseLiteralType(type: ts.Type): type is FalseLiteralType;
/**
 * Test if a type is a `TupleTypeReference`.
 *
 * @category Types - Type Guards
 */
declare function isTupleTypeReference(type: ts.Type): type is ts.TupleTypeReference;

/**
 * Test if a type is a `EvolvingArrayType`.
 *
 * @category Types - Type Guards
 */
declare function isEvolvingArrayType(type: ts.Type): type is ts.EvolvingArrayType;
/**
 * Test if a type is a `TupleType`.
 *
 * @category Types - Type Guards
 */
declare function isTupleType(type: ts.Type): type is ts.TupleType;
/**
 * Test if a type is a `TypeReference`.
 *
 * @category Types - Type Guards
 */
declare function isTypeReference(type: ts.Type): type is ts.TypeReference;

/**
 * Test if a type is a `BigIntLiteralType`.
 *
 * @category Types - Type Guards
 */
declare function isBigIntLiteralType(type: ts__default.Type): type is ts__default.BigIntLiteralType;
/**
 * Test if a type is a `ConditionalType`.
 *
 * @category Types - Type Guards
 */
declare function isConditionalType(type: ts__default.Type): type is ts__default.ConditionalType;
/**
 * Test if a type is a `EnumType`.
 *
 * @category Types - Type Guards
 */
declare function isEnumType(type: ts__default.Type): type is ts__default.EnumType;
/**
 * Test if a type is a `IndexType`.
 *
 * @category Types - Type Guards
 */
declare function isIndexType(type: ts__default.Type): type is ts__default.IndexType;
/**
 * Test if a type is a `IndexedAccessType`.
 *
 * @category Types - Type Guards
 */
declare function isIndexedAccessType(type: ts__default.Type): type is ts__default.IndexedAccessType;
/**
 * Test if a type is a `InstantiableType`.
 *
 * @category Types - Type Guards
 */
declare function isInstantiableType(type: ts__default.Type): type is ts__default.InstantiableType;
/**
 * Test if a type is a `IntersectionType`.
 *
 * @category Types - Type Guards
 */
declare function isIntersectionType(type: ts__default.Type): type is ts__default.IntersectionType;
/**
 * Test if a type is a `NumberLiteralType`.
 *
 * @category Types - Type Guards
 */
declare function isNumberLiteralType(type: ts__default.Type): type is ts__default.NumberLiteralType;
/**
 * Test if a type is a `ObjectType`.
 *
 * @category Types - Type Guards
 */
declare function isObjectType(type: ts__default.Type): type is ts__default.ObjectType;
/**
 * Test if a type is a `StringLiteralType`.
 *
 * @category Types - Type Guards
 */
declare function isStringLiteralType(type: ts__default.Type): type is ts__default.StringLiteralType;
/**
 * Test if a type is a `StringMappingType`.
 *
 * @category Types - Type Guards
 */
declare function isStringMappingType(type: ts__default.Type): type is ts__default.StringMappingType;
/**
 * Test if a type is a `SubstitutionType`.
 *
 * @category Types - Type Guards
 */
declare function isSubstitutionType(type: ts__default.Type): type is ts__default.SubstitutionType;
/**
 * Test if a type is a `TemplateLiteralType`.
 *
 * @category Types - Type Guards
 */
declare function isTemplateLiteralType(type: ts__default.Type): type is ts__default.TemplateLiteralType;
/**
 * Test if a type is a `TypeParameter`.
 *
 * @category Types - Type Guards
 */
declare function isTypeParameter(type: ts__default.Type): type is ts__default.TypeParameter;
/**
 * Test if a type is a `TypeVariable`.
 *
 * @category Types - Type Guards
 */
declare function isTypeVariable(type: ts__default.Type): type is ts__default.TypeVariable;
/**
 * Test if a type is a `UnionType`.
 *
 * @category Types - Type Guards
 */
declare function isUnionType(type: ts__default.Type): type is ts__default.UnionType;
/**
 * Test if a type is a `UnionOrIntersectionType`.
 *
 * @category Types - Type Guards
 */
declare function isUnionOrIntersectionType(type: ts__default.Type): type is ts__default.UnionOrIntersectionType;
/**
 * Test if a type is a `UniqueESSymbolType`.
 *
 * @category Types - Type Guards
 */
declare function isUniqueESSymbolType(type: ts__default.Type): type is ts__default.UniqueESSymbolType;

/**
 * Determines whether a type is definitely falsy. This function doesn't unwrap union types.
 *
 * @category Types - Utilities
 */
declare function isFalsyType(type: ts.Type): boolean;
/**
 * Determines whether writing to a certain property of a given type is allowed.
 *
 * @category Types - Utilities
 */
declare function isPropertyReadonlyInType(type: ts.Type, name: ts.__String, typeChecker: ts.TypeChecker): boolean;
/**
 * Determines whether a type is thenable and thus can be used with `await`.
 *
 * @category Types - Utilities
 */
declare function isThenableType(typeChecker: ts.TypeChecker, node: ts.Node, type: ts.Type): boolean;
/**
 * Determines whether a type is thenable and thus can be used with `await`.
 *
 * @category Types - Utilities
 */
declare function isThenableType(typeChecker: ts.TypeChecker, node: ts.Expression, type?: ts.Type): boolean;
/**
 * Used by {@link someTypePart}.
 *
 * @category Callbacks
 */
type SomeTypePartPredicate = (subType: ts.Type) => subType is ts.UnionOrIntersectionType;
/**
 * Used by {@link someTypePart}.
 *
 * @category Callbacks
 */
type SomeTypePartCallback = (subType: ts.Type) => boolean;
/**
 * If the given predicate holds for the given type,
 * test that some type part of that union or intersection passes the callback test.
 * Otherwise, test the give type itself with the callback.
 *
 * @category Types - Utilities
 */
declare function someTypePart(type: ts.Type, predicate: SomeTypePartPredicate, callback: SomeTypePartCallback): boolean;
/**
 * Test if the given symbol has a readonly declaration.
 *
 * @category Symbols - Utilities
 */
declare function symbolHasReadonlyDeclaration(symbol: ts.Symbol, typeChecker: ts.TypeChecker): boolean;
/**
 * Get the union type parts of the given type.
 *
 * If the given type is not a union type, an array contain only that type will be returned.
 *
 * @category Types - Utilities
 */
declare function unionTypeParts(type: ts.Type): ts.Type[];

export { AnyKeyword, BigIntKeyword, BooleanCompilerOptions, BooleanKeyword, BooleanLiteralType, ConstAssertionExpression, ConstAssertionIdentifier, FalseKeyword, FalseLiteralType, ForEachCommentCallback, ForEachTokenCallback, ImportKeyword, NamedDeclarationWithName, NeverKeyword, NullKeyword, NumberKeyword, NumericOrStringLikeLiteral, ObjectKeyword, SomeTypePartCallback, SomeTypePartPredicate, StrictCompilerOption, StringKeyword, SuperKeyword, SymbolKeyword, ThisKeyword, TrueKeyword, TrueLiteralType, UndefinedKeyword, UnknownKeyword, UnknownLiteralType, VoidKeyword, forEachComment, forEachToken, getCallSignaturesOfType, getPropertyOfType, getWellKnownSymbolPropertyOfType, hasModifier, isAbstractKeyword, isAccessExpression, isAccessibilityModifier, isAccessorDeclaration, isAccessorKeyword, isAnyKeyword, isArrayBindingElement, isArrayBindingOrAssignmentPattern, isAssertKeyword, isAssertsKeyword, isAssignmentKind, isAssignmentPattern, isAsyncKeyword, isAwaitKeyword, isBigIntKeyword, isBigIntLiteralType, isBindingOrAssignmentElementRestIndicator, isBindingOrAssignmentElementTarget, isBindingOrAssignmentPattern, isBindingPattern, isBlockLike, isBooleanKeyword, isBooleanLiteral, isBooleanLiteralType, isClassLikeDeclaration, isClassMemberModifier, isColonToken, isCompilerOptionEnabled, isConditionalType, isConstAssertionExpression, isConstKeyword, isDeclarationName, isDeclarationWithTypeParameterChildren, isDeclarationWithTypeParameters, isDeclareKeyword, isDefaultKeyword, isDestructuringPattern, isDotToken, isEndOfFileToken, isEntityNameExpression, isEntityNameOrEntityNameExpression, isEnumType, isEqualsGreaterThanToken, isEqualsToken, isEvolvingArrayType, isExclamationToken, isExportKeyword, isFalseKeyword, isFalseLiteral, isFalseLiteralType, isFalsyType, isForInOrOfStatement, isFunctionLikeDeclaration, isFunctionScopeBoundary, isHasDecorators, isHasExpressionInitializer, isHasInitializer, isHasJSDoc, isHasModifiers, isHasType, isHasTypeArguments, isImportExpression, isImportKeyword, isInKeyword, isIndexType, isIndexedAccessType, isInputFiles, isInstantiableType, isIntersectionType, isIterationStatement, isJSDocComment, isJSDocNamespaceBody, isJSDocNamespaceDeclaration, isJSDocText, isJSDocTypeReferencingNode, isJsonMinusNumericLiteral, isJsonObjectExpression, isJsxAttributeLike, isJsxAttributeValue, isJsxChild, isJsxTagNameExpression, isJsxTagNamePropertyAccess, isLiteralToken, isModifierFlagSet, isModuleBody, isModuleName, isModuleReference, isNamedDeclarationWithName, isNamedImportBindings, isNamedImportsOrExports, isNamespaceBody, isNamespaceDeclaration, isNeverKeyword, isNodeFlagSet, isNullKeyword, isNullLiteral, isNumberKeyword, isNumberLiteralType, isNumericOrStringLikeLiteral, isNumericPropertyName, isObjectBindingOrAssignmentElement, isObjectBindingOrAssignmentPattern, isObjectFlagSet, isObjectKeyword, isObjectType, isObjectTypeDeclaration, isOutKeyword, isOverrideKeyword, isParameterPropertyModifier, isPrivateKeyword, isPropertyAccessEntityNameExpression, isPropertyNameLiteral, isPropertyReadonlyInType, isProtectedKeyword, isPseudoLiteralToken, isPublicKeyword, isQuestionDotToken, isQuestionToken, isReadonlyKeyword, isSignatureDeclaration, isStaticKeyword, isStrictCompilerOptionEnabled, isStringKeyword, isStringLiteralType, isStringMappingType, isSubstitutionType, isSuperElementAccessExpression, isSuperExpression, isSuperKeyword, isSuperProperty, isSuperPropertyAccessExpression, isSymbolFlagSet, isSymbolKeyword, isSyntaxList, isTemplateLiteralType, isThenableType, isThisExpression, isThisKeyword, isTrueKeyword, isTrueLiteral, isTrueLiteralType, isTupleType, isTupleTypeReference, isTypeFlagSet, isTypeOnlyCompatibleAliasDeclaration, isTypeParameter, isTypeReference, isTypeReferenceType, isTypeVariable, isUndefinedKeyword, isUnionOrIntersectionType, isUnionOrIntersectionTypeNode, isUnionType, isUniqueESSymbolType, isUnknownKeyword, isUnknownLiteralType, isUnparsedPrologue, isUnparsedSourceText, isUnparsedSyntheticReference, isValidPropertyAccess, isVariableLikeDeclaration, isVoidKeyword, someTypePart, symbolHasReadonlyDeclaration, unionTypeParts };
